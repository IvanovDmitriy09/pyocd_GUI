unit Unit1;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls;

type
  TForm1 = class(TForm)
    Button1: TButton;
    Button2: TButton;
    Memo1: TMemo;
    procedure Button2Click(Sender: TObject);
    procedure Button1Click(Sender: TObject);
  private
    { Private declarations }
  public
    { Public declarations }
  end;

var
  Form1: TForm1;
  rc: cardinal;
  
implementation

{$R *.dfm}

Function GetDosOutput( const CommandLine, WorkDir: String; var
ResultCode: Cardinal ): String;
var StdOutPipeRead, StdOutPipeWrite: THandle;
   SA                             : TSecurityAttributes;
   SI                             : TStartupInfo;
   PI                             : TProcessInformation;
   WasOK                          : Boolean;
   Buffer                         : array[0..255] of Char;
   BytesRead                      : Cardinal;
   Line                           : String;
Begin
   //Application.ProcessMessages;
   With SA do
   Begin
      nLength := SizeOf( SA );
      bInheritHandle := True;
      lpSecurityDescriptor := nil;
   end;
   // ??????? ???? ??? ??????????????? ???????????? ??????
   CreatePipe( StdOutPipeRead,  // ?????????? ??????
               StdOutPipeWrite, // ?????????? ??????
               @SA,              // ????????? ????????????
               0                // ?????????? ???? ???????? ??? ????? - 0 ?? ?????????
              );
   try
    // ??????? ???????? ???????, ????????? StdOutPipeWrite ? ???????? ???????????? ??????,
    // ? ??? ?? ?????????, ????? ?? ?? ??????????? ?? ??????.
    with SI do
    Begin
       FillChar( SI, SizeOf( SI ), 0 );
       cb := SizeOf( SI );
       dwFlags := STARTF_USESHOWWINDOW or STARTF_USESTDHANDLES;
       wShowWindow := SW_HIDE;
       hStdInput := GetStdHandle( STD_INPUT_HANDLE ); // ??????????? ???? ?? ??????????????
       hStdOutput := StdOutPipeWrite;
       hStdError := StdOutPipeWrite;
    end;

    //????????? ?????????? ?? ????????? ??????
    //WorkDir := ExtractFilePath(CommandLine);
    WasOK := CreateProcess( nil,
                            PChar( CommandLine ),
                            nil,
                            nil,
                            True,
                            0,
                            nil,
                            PChar( WorkDir ),
                            SI,
                            PI );
    // ??????, ????? ?????????? ???????, ??? ???????????? ????????? ??????.
    // ??? ?? ?????, ????? ????????? ????????? ?????? ??? ??????.
    CloseHandle( StdOutPipeWrite );
    // ???? ??????? ????? ???? ??????, ?? ??????????, ??? ??? ?????
    if not WasOK then
     raise Exception.Create( '?????? ?????????? ??? ??????????: ' +
            Chr( 10 ) + Chr( 13 ) + CommandLine )
    else
      try
        // ???????? ???? ????? ?? ??? ???, ???? DOS-?????????? ?? ????? ?????????
        Line := '';
        Repeat
           // ?????? ???? ???????? (????? ????????? ???????? ??????? ? ???????? ??????)
           WasOK := ReadFile( StdOutPipeRead, Buffer, 255, BytesRead, nil );
           // ???? ?? ???-?????? ??? ??? ???????
           if BytesRead > 0 then
           Begin
              // ????????? ????? PChar-??
              Buffer[BytesRead] := #0;
              // ????????? ????? ? ????? ?????
              Line := Line + Buffer;
           end;
           //Application.ProcessMessages;
        Until not WasOK or ( BytesRead = 0 );
        // ????, ???? ?????????? ?????????? ??????????
        WaitForSingleObject( PI.hProcess, INFINITE );
        ResultCode := 0;
        GetExitCodeProcess( PI.hProcess, ResultCode );
      finally
        // ????????? ??? ?????????? ???????????
        CloseHandle( PI.hThread );
        CloseHandle( PI.hProcess );
      end;
   finally
     Result := Line;
     CloseHandle( StdOutPipeRead );
 end;
end;


procedure TForm1.Button2Click(Sender: TObject);

begin
memo1.Text:=GetDosOutput('cmd /c pyocd list -t', 'c:\', Rc);
end;

procedure TForm1.Button1Click(Sender: TObject);
begin
memo1.Text:=GetDosOutput('cmd /c pyocd list -t', 'c:\', Rc);
end;

end.
